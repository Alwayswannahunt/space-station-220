// Â© SS220, An EULA/CLA with a hosting restriction, full text: https://raw.githubusercontent.com/SerbiaStrong-220/space-station-14/master/CLA.txt
using Content.Shared.SS220.SuperMatter.Functions;
using FancyWindow = Content.Client.UserInterface.Controls.FancyWindow;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;
using Robust.Client.UserInterface.Controls;
using Content.Shared.SS220.SuperMatter.Ui;
using Content.Client.SS220.UserInterface.PlotFigure;
using Content.Client.SS220.SuperMatter.Observer;
using System.Numerics;
using System.Linq;

namespace Content.Client.SS220.SuperMatter.Ui;

// For optimization make cache value in ServerSystem and then subscribe from client if it needs it;
[GenerateTypedNameReferences]
public sealed partial class SuperMatterObserverMenu : FancyWindow
{

    public event Action<BaseButton.ButtonEventArgs, SuperMatterObserverComponent>? OnServerButtonPressed;
    public event Action<BaseButton.ButtonEventArgs, int>? OnCrystalButtonPressed;
    public SuperMatterObserverComponent? Observer;
    public int? CrystalKey;
    public const int MAX_DATA_LENGTH = 180;
    private int counter = 0;
    private float conterAbobaX = 0f;
    private float conterAbobaY = 0f;
    public SuperMatterObserverMenu()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);
        PlotValueOverTime.SetLabels("time elapsed, s", " Integrity", " Crystal Integrity ");
        ColorState.MakeMeshgrid((1, 100, 25), (1, 100, 100));
        ColorState.EvalFunctionOnMeshgrid(GetIntegrityDamageMap);
        ColorState.SetLabels("Matter, a.u.", "Internal energy, a.u.", " Safe operation ");
    }
    public void LoadState(List<Entity<SuperMatterObserverComponent>> observerEntities)
    {
        ServerNavigationBar.RemoveAllChildren();
        foreach (var (observerUid, observerComp) in observerEntities)
        {
            var serverButton = new ServerButton
            {
                Text = observerUid.ToString(),
                ObserverComponent = observerComp,
                ToggleMode = true,
                StyleClasses = { "OpenBoth" }
            };

            serverButton.OnPressed += args => OnServerButtonPressed?.Invoke(args, serverButton.ObserverComponent);
            ServerNavigationBar.AddChild(serverButton);
        }
    }
    public void LoadCrystal()
    {
        CrystalNavigationBar.RemoveAllChildren();
        if (Observer == null)
            return;
        foreach (var (crystalKey, name) in Observer.Names)
        {
            var crystalButton = new CrystalButton
            {
                Text = name,
                CrystalKey = crystalKey,
                ToggleMode = true,
                StyleClasses = { "OpenBoth" }
            };

            crystalButton.OnPressed += args => OnCrystalButtonPressed?.Invoke(args, crystalButton.CrystalKey);
            CrystalNavigationBar.AddChild(crystalButton);
        }
    }
    public void LoadCachedData()
    {
        if (Observer == null
            || CrystalKey == null)
            return;
        PlotValueOverTime.LoadPlot2DTimePoints(new PlotPoints2D(MAX_DATA_LENGTH, Observer.Integrities[CrystalKey.Value],
                                                        -1f, -1f * Observer.Integrities[CrystalKey.Value].Count));
        ColorState.LoadMovingPoint(new Vector2(Observer.Matters[CrystalKey.Value].Last().Value, Observer.InternalEnergy[CrystalKey.Value].Last().Value),
                                     new Vector2(Observer.Matters[CrystalKey.Value].Last().Derv, Observer.InternalEnergy[CrystalKey.Value].Last().Derv));
    }
    public void UpdateState(SuperMatterObserverUpdateState msg)
    {
        if (Observer == null
            || CrystalKey == null)
            return;
        PlotValueOverTime.AddPointToPlot(new Vector2(PlotValueOverTime.GetLastAddedPointX() + 1, msg.Integrity));
        ColorState.LoadMovingPoint(new Vector2(msg.Matter.Value, msg.InternalEnergy.Value), new Vector2(msg.Matter.Derivative, msg.InternalEnergy.Derivative));
    }
    private float GetIntegrityDamageMap(float matter, float internalEnergy)
    {
        return SuperMatterFunctions.EnergyToMatterDamageFactorFunction(
                    internalEnergy - SuperMatterFunctions.SafeInternalEnergyToMatterFunction(matter / SuperMatterFunctions.MatterNondimensionalization));
    }
    private sealed class ServerButton : Button
    {
        public SuperMatterObserverComponent? ObserverComponent;
    }
    private sealed class CrystalButton : Button
    {
        public int CrystalKey;
    }
}
