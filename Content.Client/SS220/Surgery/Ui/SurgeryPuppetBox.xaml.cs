// Â© SS220, An EULA/CLA with a hosting restriction, full text: https://raw.githubusercontent.com/SerbiaStrong-220/space-station-14/master/CLA.txt

using System.Numerics;
using Content.Shared.SS220.Surgery;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.SS220.Surgery.Ui;

[GenerateTypedNameReferences]
public sealed partial class SurgeryPuppetBox : Control
{
    // SS220_TODO: if i had time add some properties not to hardcode in xaml

    public Vector2 Scale
    {
        get => _scale;
        set
        {
            _scale = value;
            ResizeAll();
        }
    }

    private Vector2 _scale = new Vector2(1f);

    public PuppetParts? SelectedPart
    {
        get => _selectedPart;
        set
        {
            _selectedPart = HighlightPuppetPart(value);
        }
    }

    private PuppetParts? _selectedPart;

    private SortedDictionary<PuppetParts, TextureRect> _parts = new();
    private SortedDictionary<PuppetParts, TextureRect> _highlightedPart = new();

    private const string TexturePath = "/Textures/SS220/Interface/Surgery/puppet";

    public SurgeryPuppetBox()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    // SS220_TODO: make it working. Add normal buttons to work... God help me...
    // fuck buttons!
    public void Initialize()
    {
        foreach (var part in Enum.GetValues<PuppetParts>())
        {
            var textPart = MakePuppetPartButton(part, _parts, GetPuppetPartTexturePath);

            if (textPart != null)
                this.AddChild(textPart);

            textPart = MakePuppetPartButton(part, _highlightedPart, GetPuppetPartSelectedTexturePath);

            if (textPart == null)
                continue;

            this.AddChild(textPart);
            textPart.Visible = false;
        }

        ResizeAll();
    }

    private Control? MakePuppetPartButton(PuppetParts part, SortedDictionary<PuppetParts, TextureRect> bodyPartTexture, Func<PuppetParts, string?> pathSpecifier)
    {
        var partTexturePath = pathSpecifier(part);

        if (partTexturePath == null)
            return null;

        var texture = new TextureRect
        {
            Stretch = TextureRect.StretchMode.Keep,
            TexturePath = partTexturePath
        };

        var partButton = new PuppetButton
        {
            Part = part,
            // TODO: make it from enum of PuppetParts
            SetSize = new Vector2(1f, 2f),
            Margin = new Thickness(1f, 2f, 3f, 4f)
        };

        bodyPartTexture.Add(part, texture);

        return texture;
    }

    private void ResizeAll()
    {
        foreach (var texture in _parts.Values)
        {
            texture.TextureScale = _scale;
        }
        foreach (var texture in _highlightedPart.Values)
        {
            texture.TextureScale = _scale;
        }
        Background.TextureScale = _scale;
    }

    /// <summary>
    /// I hope no one else will need to give a fck what happens here. God bless new med.
    /// </summary>
    private PuppetParts? HighlightPuppetPart(PuppetParts? puppetPartClicked)
    {
        var newHighlightPart = puppetPartClicked;
        switch (puppetPartClicked)
        {
            case PuppetParts.Head:
                switch (_selectedPart)
                {
                    case PuppetParts.Head:
                        newHighlightPart = PuppetParts.Eyes;
                        break;
                    case PuppetParts.Eyes:
                        newHighlightPart = PuppetParts.Mouth;
                        break;
                    case PuppetParts.Mouth:
                        newHighlightPart = PuppetParts.Head;
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }

        if (newHighlightPart == _selectedPart)
            return _selectedPart;

        if (_selectedPart != null)
            RemoveHighlight(_selectedPart.Value);

        if (newHighlightPart != null)
            MakeHighlighted(newHighlightPart.Value);

        return newHighlightPart;
    }

    private void MakeHighlighted(PuppetParts part)
    {
        if (_highlightedPart.TryGetValue(part, out var newTextureControl))
            newTextureControl.Visible = true;
        if (_parts.TryGetValue(part, out var oldTextureControl))
            oldTextureControl.Visible = false;
    }

    private void RemoveHighlight(PuppetParts part)
    {
        if (_highlightedPart.TryGetValue(part, out var newTextureControl))
            newTextureControl.Visible = false;
        if (_parts.TryGetValue(part, out var oldTextureControl))
            oldTextureControl.Visible = true;
    }


    /// <summary> If you still think why we need new med to make surgery just look into this method. </summary>
    private string? GetPuppetPartTexturePath(PuppetParts puppetPart)
    {
        var state = puppetPart switch
        {
            PuppetParts.Head => "head.png",
            PuppetParts.Torso => "torso.png",
            PuppetParts.LeftArm => "left_arm.png",
            PuppetParts.RightArm => "right_arm.png",
            PuppetParts.LeftHand => "left_hand.png",
            PuppetParts.RightHand => "right_hand.png",
            PuppetParts.LeftLeg => "left_leg.png",
            PuppetParts.RightLeg => "right_leg.png",
            PuppetParts.LeftFoot => "left_foot.png",
            PuppetParts.RightFoot => "right_foot.png",
            PuppetParts.LowerTorso => "butt.png",
            _ => null
        };

        if (state == null)
            return null;
        return string.Join('/', [TexturePath, state]);
    }

    /// <summary> If you still think why we need newMed to make surgery just look into this method too. </summary>
    private string? GetPuppetPartSelectedTexturePath(PuppetParts highlightedPuppetPart)
    {
        var state = highlightedPuppetPart switch
        {
            PuppetParts.Head => "head_selected.png",
            PuppetParts.Eyes => "eyes_selected.png",
            PuppetParts.Mouth => "mouth_selected.png",
            PuppetParts.Torso => "torso_selected.png",
            PuppetParts.LeftArm => "left_arm_selected.png",
            PuppetParts.RightArm => "right_arm_selected.png",
            PuppetParts.LeftHand => "left_hand_selected.png",
            PuppetParts.RightHand => "right_hand_selected.png",
            PuppetParts.LeftLeg => "left_leg_selected.png",
            PuppetParts.RightLeg => "right_leg_selected.png",
            PuppetParts.LeftFoot => "left_foot_selected.png",
            PuppetParts.RightFoot => "right_foot_selected.png",
            PuppetParts.LowerTorso => "butt_selected.png",
            _ => null
        };

        if (state == null)
            return null;
        return string.Join('/', [TexturePath, state]);
    }
}

public sealed class PuppetButton : BaseButton
{
    public PuppetParts Part;
}


